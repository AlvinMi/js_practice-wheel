# CSS 实际上是如何工作的？
分两个处理阶段:
- 1.浏览器将 HTML 和 CSS 转化成 DOM （文档对象模型）。DOM 在计算机内存中表示文档。它把文档内容和其样式结合在一起。
- 2.浏览器显示 DOM 的内容。

## 关于 DOM 
DOM 是一种树形结构. 标记语言中的每个元素, 属性, 文本片段都变为一个 DOM 节点。这些节点由它们与其它 DOM 节点的关系来定义。有的元素是某些子节点的父节点，且这些子节点有兄弟（节点）。


## CSS 语法
### CSS 声明
给 CSS 属性设置特定的值是 CSS 语言的核心功能。CSS 引擎会通过计算，将对应的 CSS 声明应用到页面的每一个元素上，从而使得元素们以适当的方式布局，并展示出适当的样式。特别需要记住的是，CSS 的属性和属性值都是区分大小写的。属性和属性值之间，用英文半角冒号 (:) 隔离，如下图所示。

### 选择器和规则
选择器是一种模式，它能在页面上匹配一些元素。这将使相关的声明仅被应用到被选择的元素上。选择器加上声明块被称为规则集（ruleset），通常简称规则（rule）。

一个元素可以被多个选择器所匹配，因此，一个给定的属性可能被多个规则设置多次。 CSS 定义了哪个规则比其它规则更具优先级，则更具优先级的规则必定被应用：这被称为层叠算法（cascade algorithm），关于层叠算法的更多内容和运作原理见[层叠和继承](https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Introduction_to_CSS/Cascade_and_inheritance)。

## 选择器的分类
- 1.简单选择器: 通过元素类型、class或id匹配一个或者多个元素
- 2.属性选择器: 通过属性/属性值匹配一个或多个元素
- 3.伪类: 匹配处于确定状态的一个或多个元素, 比如被鼠标指针悬停的元素, 或当前被选中或未选中的复选框, 或元素是 DOM 树中一父节点的第一个子节点。
- 4.伪元素: 匹配处于相关的确定位置的一个或多个元素, 例如每个段落的第一个字, 或者某个元素之前生成的内容。
- 5.组合器: 不仅仅是选择器本身, 还有以有效的方式组合两个或更多的选择器用于非常特定的选择的方法。
- 6.多重选择器: 是将以逗号分隔开的多个选择器放在一个 CSS 规则下面， 以将一组声明应用于由这些选择器选择的所有元素。

### 简单选择器
基于元素的类型（或其 class或 id）直接匹配文档的一个或多个元素。

类型选择器(又名元素选择器):
该选择器只是一个选择器名和指定的 HTML 元素名的不区分大小写的匹配。这是选择所有指定类型的最简单方式。让我们一起看看下面这个例子:
```html
<p>What color do you like?</p>
<div>I like blue.</div>
<p>I prefer red!</p>
```
演示表:
```css
p{
    color: red;
}

div{
    color: red;
}
```

#### 类选择器
类选择器由一个点 “.” 以及类后面的类名组成。类名是在 HTML class文档元素属性中没有空格的任何值。由你自己选择一个名字。同样值得一提的是，文档中的多个元素可以具有相同的类名，而单个元素可以有多个类名 (以空格分开多个类名的形式书写)。以下是一个简单的例子：

```html
<ul>
  <li class="first done">Create an HTML document</li>
  <li class="second done">Create a CSS style sheet</li>
  <li class="third">Link them all together</li>
</ul>
```
样式表:
```css
.first {
    font-weight； blod;
}

.done {
    text-decoration: line-through;
}
```

#### ID 选择器
ID 选择器由哈希 / 磅符号 (#) 组成，后面是给定元素的 ID 名称。 任何元素都可以使用 id属性设置唯一的 ID 名称。 由你自己选择的 ID 是什么。 这是选择单个元素的最有效的方式。

### 属性选择器
属性选择器是一种特殊类型的选择器，它根据元素的 属性 和属性值来匹配元素。它们的通用语法由方括号 ([]) 组成，其中包含属性名称，后跟可选条件以匹配属性的值。 属性选择器可以根据其匹配属性值的方式分为两类： 
- 存在和值属性选择器
- 子串值属性选择器。

#### 存在和值属性选择器
属性选择器尝试匹配精确的属性值：
- `[attr]`：该选择器选择包含 attr 属性的所有元素，不论 attr 的值为何。
- `[attr=val]`：该选择器仅选择 attr 属性被赋值为 val 的所有元素。
- `[attr~=val]`：该选择器仅选择具有 attr 属性的元素，而且要求 val 值是 attr 值包含的被空格分隔的取值列表里中的一个。例子: index.html

例子中的 `data-*` 被成为数据属性。提供了一种在 HTML 属性中存储自定义数据的方法，由此，这些数据可以轻松地被提取和使用。有关详细信息，请参阅 [如何使用数据属性](https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Using_data_attributes)。

#### 子串值属性选择器
这种情况的属性选择器也被称为 “伪正则选择器”，因为它们提供**类似** regular expression(正则表达式) 的灵活匹配方式（但请注意，这些选择器并不是真正的正则表达式）：
- `[attr|=val]` : 选择 attr 属性的值是 val 或值以 val- 开头的元素（注意，这里的 `-` 不是一个错误，这是用来处理语言编码的）。
- `[attr^=val]` : 选择 attr 属性的值以 val 开头（包括 val）的元素。
- `[attr$=val]` : 选择 attr 属性的值以 val 结尾（包括 val）的元素。
- `[attr*=val]` : 选择 attr 属性的值中包含子字符串 val 的元素（一个子字符串就是一个字符串的一部分而已，例如，`cat` 是 字符串`caterpillar` 的子字符串）。

继续前面例子, 添加 css 规则.

### 伪类和伪元素
一个 CSS 伪类是以冒号 `:` 作为前缀, 被添加到一个选择器末尾的关键字, 在特定状态下才被呈现到指定的元素。 可以往元素的选择器后面加上对应的伪类（pseudo-class）。

例如当鼠标悬停在元素上面时，或者当一个复选框被禁用或被勾选时，又或者当一个元素是它在 DOM 树中父元素的第一个子元素时。

练习例子。

伪元素:
伪元素（Pseudo-element）跟伪类很像，但它们又有不同的地方。它们都是关键字，但这次伪元素前缀是两个冒号 (::) ， 同样是添加到选择器后面去选择某个元素的某个部分。
- ::after
- ::before
- ::first-letter
- ::first-line
- ::selection
- ::backdrop

每个都拥有特别的行为和有趣的特性。
一个伪元素的例子, 在所有的超链接后面增加一个箭头。

### 组合器多种选择器
虽然一次使用一个选择器就很有用，但在某些情形中却可能效率低下。 CSS 选择器在你开始组合他们进行细粒度选择的时候变得更具使用价值。基于元素之间的相互关联关系，CSS 提供了几种方法来对元素进行选择。下表使用连接符展示了这些关联关系 (A 和 B 代表前文所述的任意选择器):


|Combinators|Select|
|:----|:---:|
|A,B  | 匹配满足 A（和 / 或）B 的任意元 |
|A B  | 匹配任意元素，满足条件：B 是 A 的后代结点（B 是 A 的子节点，或者 A 的子节点的子节点） |
|A > B| 匹配任意元素，满足条件：B 是 A 的直接子节点 |
|A + B| 匹配任意元素，满足条件：B 是 A 的下一个兄弟节点（AB 有相同的父结点，并且 B 紧跟在 A 的后面）|
|A ~ B| 匹配任意元素，满足条件：B 是 A 之后的兄弟节点中的任意一个（AB 有相同的父节点，B 在 A 之后，但不一定是紧挨着 A） |

例子: Combinators.html

## CSS 的值和单位
属性的值有哪些种类，以及表示长度、颜色或者其他你想要的值时可以用的单位。    

CSS 中，值的类型有很多种，一些很常见，一些几乎没怎么遇到过。不会在这里,面面俱到地描述他们，而只是这些对于掌握 CSS 可能最有用处的这些。本文将会涉及如下 CSS 的值：
- 数值: 
    - 长度值，用于指定例如元素宽度、边框（border）宽度或字体大小；
    - 无单位整数。用于指定例如相对线宽或运行动画的次数。
- 百分比: 可以用于指定尺寸或长度——例如取决于父容器的长度或高度，或默认的字体大小。
- 颜色: 用于指定背景颜色，字体颜色等。
- 坐标位置: 例如，以屏幕的左上角为坐标原点定位元素的位置。
- 函数: 例如，用于指定背景图片或背景图片渐变。

例子 `CSS values and units` 目录下 index.html 做了以下的事情:
- 分别将每个段落 margin、padding 和 border-width 设置为 5 pixels, 10 pixels 和 2 pixels. 一个单独的 margin/padding 值表示所有 4 个面都被设置成同样的值。边框也被设置成了 border 的缩写值。
- 为三个不同的段落设置越来越大的宽度 (width) 像素值, 也就是说越往下盒子越来越大。
- 为三个不同的段落设置越来越大字号（ font-size）像素值，也就是意味着越往下文本越大。font-size代表字体/字形的高度。

像素 (px) 是一种绝对单位（absolute units）， 因为无论其他相关的设置怎么变化，像素指定的值是不会变化的。其他的绝对单位如下：
- mm, cm, in: 毫米（Millimeters），厘米（centimeters），英寸（inches）
- pt, pc: 点（Points (1/72 of an inch)）， 十二点活字（ picas (12 points.)）

相对单位:
- em:1em 与当前元素的字体大小相同（更具体地说，一个大写字母 M 的宽度）。CSS 样式被应用之前，浏览器给网页设置的默认基础字体大小是 16 像素，这意味着对一个元素来说 1em 的计算值默认为 16 像素。但是要小心—em 单位是会继承父元素的字体大小，所以如果在父元素上设置了不同的字体大小，em 的像素值就会变得复杂。现在不要过于担心这个问题，我们将在后面的文章和模块中更详细地介绍继承和字体大小设置。**em 是 Web 开发中最常用的相对单位**。
- ex, ch: 分别是小写 x 的高度和数字 0 的宽度。这些并不像 em 那样被普遍使用或很好地被支持。
- rem: REM（root em）和 em 以同样的方式工作，但它总是等于默认基础字体大小的尺寸；继承的字体大小将不起作用，所以这听起来像一个比 em 更好的选择，虽然在旧版本的 IE 上不被支持.
- vw, vh: 分别是视口宽度的 1/100 和视口高度的 1/100，其次，它不像 rem 那样被广泛支持。

#### 无单位的值
在CSS 中，你有时会遇到一些无单位的数值——这并不总是意味着错误，在某些情况下，使用无单位的数值是完全允许的。例如，如果你想让一个元素完全去除外边框和内边框，你可以只使用无单位的 0——因为 0 就是 0，不管单位是什么！
- 无单位的行高: 另一个例子是 line-height，设置元素中每行文本的高度。

#### 百分比
大部分使用特定数值指定的内容同样可以使用百分比来指定。通过 `CSS values and units` 下面的 `index.html` 来说, 百分比的好处是 即使视口大小被调整, 第二个 div 的宽度也会随着视口的变化而变化, 

这两个 div 的框局类型通常被成为 **动态(流体)布局** (跟随浏览器视口大小的变化) 和 **固定宽度布局**(不管怎样都保持不变), 两种布局方式有着不同的应用场景：
- 可以使用动态布局来确保标准文档始终适合于屏幕，并且可以在不同大小的移动设备屏幕上表现良好。
- 一个固定宽度的布局可以用来保持在线地图的大小相同；浏览器视口可以在地图上滚动，只在一个时间内查看一定数量的地图。您可以立即看到的量取决于您的视口有多大。

后面也将会学习更多的网页的布局。 CSS 布局和 响应式设计模块。

实践练习, length 练习: 体验一下，改变 .inner 和 .outer 的 width/height 的值，会带来什么变化。

#### 颜色
说一下: 
- RGBA 和 HSLA：
透明色对于产生更丰富的视觉效果非常有用——例如混合的背景, 半透明的 UI 元素等等。
- 颜色练习, 思考它们之间的关系。

#### 函数
function 是代码中可重复使用的部分, 也作为属性值存放于 CSS 中, 例如前面看到的 `rgba()`,`hsl()`。
在其他地方也会看到函数——每当你看到一个名字后跟着括号, 括号里包含用逗号分隔的一个或多个值, 那么你所使用的就是一个函数。例如:
```js
/* calculate the new position of an element after it has been rotated by 45 degress */
transform: rotate(45deg);
/* calculate the new position of an element after it has been moved across 50px and down 60px */
transform: translate(50px, 60px);
/* calculate the computed value of 90% of the current width minus 15px */
width: calc(90%-15px);
/* fetch an image from the network to be used as a background image */
background-image: url('myimage.png');
```
css 还是很有意思的。

### 叠层与继承
在实际的工作中，我们可能还有些疑惑，当有多个选择器作用在一个元素上时，哪个规则最终会应用到元素上？其实这是通过层叠机制来控制的，这也和样式继承 (元素从其父元素那里获得属性值) 有关。

什么选择器在层叠中胜出取决于三个因素（这些都是按重量级顺序排列的——前面的的一种会否决后一种）：
- 1.重要性(importence)
- 2.专用性(Specificity)
- 3.源代码次序(Source order)

重要性:
在 CSS 中，有一个特别的语法可以让一条规则总是优先于其他规则：`!important`。把它加在属性值的后面可以使这条声明有无比强大的力量。 

CSS 的特性, 首先想到继承性, 需要知道哪些属性具有继承性，哪些属性没有继承性。
- 选择器的优先级为: ID 选择器 > 类选择器 > 标签选择器。当多个选择器，选择上了某个元素的时候，要按照如下顺序统计权重：id 选择器数量, 类选择器数量, 标签选择器数量。
- 计算权重, 需要数一下 id 选择器的数量, 类选择器的数量, 标签选择器的数量。
    - 1.先看有没有被选中, 选中了以(id 数，类数，标签数) 来计算权重。谁大就听谁的，如果都一样听后者的，后面覆盖前面。
    - 2.如果都没有选中，那么权重为 0。如果大家都是 0，就近原则。
同一个标签，携带了多个类名，有冲突：
```js
1   <p class="test1 test2">我是什么颜色？</p>
2   <p class="test2 test1">我是什么颜色？</p>
// 和在标签中的挂类名的书序无关，只和css的顺序有关：
1       .test2{
2           color:blue;
3       }
4       .test1{
5           color:red;
6       }
7   </style>
// 红色的。因为css中red写在后面。。
// 这个题目之前在 jjc 群里也看到了, 开始是由推特上的发起的。有点意思, 和类无关, 看 css 后者覆盖前者。很简单的例子
```

关于 `!important` :
- !important 提升的是一个属性，而不是一个选择器.
- !important 无法提升继承的权重，该是 0 还是 0.
- !important 不影响就近原则.

各种选择器的兼容性:
```css
/* IE6 层面兼容的选择器： 标签选择器、id 选择器、类选择器、后代、交集选择器、并集选择器、通配符。如下： */
p
#box
.spec
div p
div.spec
div,p
*

/* IE7 能够兼容的：儿子选择器、下一个兄弟选择器。如下： */
div>p
h3+p

/* IE8 能够兼容的： */
ul li:first-child
ul li:last-child
```

练习叠层@

## 盒子模型
### padding 
内边距。位于内容的框的外边缘与边界的内边缘之间。

### border 
分隔层。位于内边距的外边缘以及外边距的内边缘之间。边界默认大小为0，从而让它不可见，不过可以设置它的厚度、风格和颜色使它出现。

### margin 
外边距。

overflow:
- auto: 当内容过多，溢流的内容被隐藏，然后出现滚动条来让我们滚动查看所有的内容。
- hidden: 当内容过多，溢流的内容被隐藏。
- visible: 当内容过多，溢流的内容被显示在盒子的外边（这个是默认的行为）。

background-clip:
设置元素的背景（背景图片或颜色）是否延伸到边框下面。

默认情况下, 背景延伸到了边界外沿。假使你有一个平铺的背景图，你只想要它延伸到内容的边沿会怎么做？可以设置 background-clip 来设置。

- border-box
背景延伸到边框外沿（但是在边框之下）。
- padding-box
边框下面没有背景，即背景延伸到内边距外沿。
- content-box
背景裁剪到内容区 (content-box) 外沿。
- text
背景被裁剪为文字的前景色 (只有 chrome 支持)。

#### Outline 
 一个框的 outline 是一个看起来像是边界但又不属于框模型的东西。它的行为和边界差不多，但是并不改变框的尺寸（更准确的说，轮廓被勾画于在框边界之外，外边距区域之内）

 ### CSS 框类型
 CSS 还有一些表现不同的其他框类型。我们可以通过 display属性来设定元素的框类型。display属性有很多的属性值。在本篇文章，我们将关注三个最常见的类型：block, inline, and inline-block。

默认状态下 display 属性值，块级元素display: block ，行内元素display: inline

 - 块框（ block box）是定义为堆放在其他框上的框（例如：其内容会独占一行），而且可以设置它的宽高，之前所有对于框模型的应用适用于块框 （ block box）
 - 行内框（ inline box）与块框是相反的，它随着文档的文字（例如：它将会和周围的文字和其他行内元素出现在同一行，而且它的内容会像一段中的文字一样随着文字部分的流动而打乱），对行内盒设置宽高无效，设置 padding, margin 和 border 都会更新周围文字的位置，但是对于周围的的块框（ block box）不会有影响。
 - 行内块状框（inline-block box） 像是上述两种的集合：它不会重新另起一行但会像行内框（ inline box）一样随着周围文字而流动，而且他能够设置宽高，并且像块框一样保持了其块特性的完整性，它不会在段落行中断开。（在下面的示例中，行内块状框会放在第二行文本上，因为第一行没有足够的空间，并且不会突破两行。然而，如果没有足够的空间，行内框会在多条线上断裂，而它会失去一个框的形状。）


作业: 做一个小卡片

## 样式化文字
设置文字的粗细，字体和样式，文字的属性简写，文字的对齐，和其他效果，以及行和字母间距。

- 使用 <br> 元素换行。

用于样式文本的 CSS 属性通常可以分为两类：
- 字体样式: 作用于字体的属性，会直接应用到文本中，比如使用哪种字体，字体的大小是怎样的，字体是粗体还是斜体，等等。
- 文本布局风格: 作用于文本的间距以及其他布局功能的属性，比如，允许操纵行与字之间的空间，以及在内容框中，文本如何对齐。

包含在元素中的文本是作为一个单一的实体。不能将文字其中一部分选中或添加样式，如果你要这么做，那么你必须要用适合的元素来包装它们，比如 ( `<span>` 或者 `<strong>`), 或者使用伪元素，像`::first-letter` (选中元素文本的第一个字母), `::first-line` (选中元素文本的第一行), 或者 `::selection` (当前光标双击选中的文本)。

- text-shadow 
- text-align 

CSS 计数器提供用于自定义列表计数和样式的高级工具，但它们相当复杂。 如果你想更深入了解, 再查看相关的内容吧。

## 样式链接
- `:link — :visited — :hover — :active`。
- 样式化为按钮. 其实就是 css 写个边框。

## Web 文字
- 下载使用自定义字体和 web 页面，以允许更多不同的、自定义的文本样式。
- CSS 的开始处有一个 `@font-face` 块，它指定要下载的字体文件。
- 练习: 社区学校主页的文本样式化。

# style boxes
这节了解一些高级特性。比如, 多图背景、渐变色； 圆角、边框图像；样式化表格；高级盒子效果例如边框阴影、混合模式和过滤器。

需要记住的点:
- 如果盒子的高度被设置为百分比长度，那么盒子高度不会遵循这个设置了的百分比长度，而是总会采用盒子内容的高度，除非给它设置了一个绝对高度（例如，像素或者 em）。
- 边界（border）也会忽略百分比宽度设置。
- 外边距（margin）有一个特殊的行为，称为 外边距塌陷： 当两个盒子挨在一起时，二者之间的距离为两个挨着的外边距中最大的那个值，而不是二者的和。

- 溢出时, 使用 overflow 属性。
    - auto：如果内容太多，那么超出盒子大小的内容会被隐藏，滚动条显示出来，从而可以让用户滚动看到所有内容。
    - hidden：如果内容太多，那么超出盒子大小的内容被隐藏了。
    - visible：如果内容太多，超出盒子大小的内容显示在盒子之外（这通常是默认的行为）。
- 背景: 盒背景由颜色和图像组成, background-color、background-image。
- 轮廓: outline .
- 一个盒子的总宽度是它的 `width`， `padding-right`，`padding-left`，`border-right`和 `border-left`属性之和。
    -  box-sizing调整盒模型。 用值 border-box，它将盒模型更改为这样新的模型：
    ![新的模型](https://mdn.mozillademos.org/files/13649/box-model-alt-small.png)

- 元素的盒子类型: 用 display 属性指定。三种常见的值为: 
    - block。被定义为堆放在其它盒子之上的盒子（即盒子之前以及之后的内容出现在不同的行上）
    - inline。与块盒相反：它跟随文档的文本流堆放（即，它会与周围的文本和其它行内元素出现在同一行，并且其内容会像段落中的文本行一样，随着文本流换行）。宽度和高度设置对行内盒无效；在行内盒上的所有内边距、外边距和边界设置会改变周围文本的位置，但是不会影响周围块盒的位置。
    - inline-block。介于前两者之间： 它会像行内盒一样，跟随周围的文本流堆放，不会在其前后创建换行；不过，它可以像块盒一样，使用宽度和高度设置大小，并且维护其块完整性 — 它不会跨段落行换行（对于一行文本容纳不下的行内盒，会落到第二行上，因为第一行上没有足够的空间容纳它，并且不会跨两行换行）
    - 块级元素默认设置为 display: block; ，行内元素默认设置为 display: inline。
- 不常见的显示类型(后面布局中用到):
    - display: table — 允许你像处理 table 布局那样处理非 table 元素，而不是滥用 HTML 的 `<table>` 标签来达到同样的目的。了解更多相关信息，请查看 CSS tables。
    - display: flex — 允许你处理一些困扰 CSS 已久的一些传统布局问题，例如布置一系列弹性等宽容器或者垂直居中内容。了解更多相关信息，请查看 Flexbox。
    - display: grid — 给出一种简单实现 CSS 网格系统的方式，而在传统上它依赖于一些棘手难以处理的 CSS 网格框架，我们的 CSS Grids 文章讲述了如何去运用传统的 CSS 网格框架。

# CSS 布局
现在可以深入到 CSS 布局，查看不同的显示设置，涉及浮动和定位的传统布局方法，以及像 flexbox 这样的现代布局工具。
- 介绍 CSS 布局(每种技术都有它们的用途,各有优缺点)。
- 浮动
- 定位
- 练习定位案例
- 弹性盒子
- 网格布局

布局技术会覆盖默认的布局行为：
- `position` 属性 -- 正常布局流中，默认为 static ，使用其它值会引起元素不同的布局方式，例如将元素固定到浏览器视口的左上角。
- 浮动——应用 float 值，诸如 left 能够让块级元素互相并排成一行，而不是一个堆叠在另一个上面。
- display 属性——标准值 block, inline or inline-block 会改变元素在正常布局流中的行为方式 (见 Types of CSS boxes )，而一些不常见或特殊的值允许我们使用完全不同的方式进行布局，使用工具比如 Flexbox。

## 浮动
四个值:
- left — 将元素浮动到左侧。
- right — 将元素浮动到右侧。
- none — 默认值, 不浮动。
- inherit — 继承父元素的浮动属性。

所有在浮动下面的自身不浮动的内容都将围绕浮动元素进行包装，如果没有处理这些元素，就会变得很糟糕。

可以使用 clear 属性解决这个问题。clear 可以取三个值:
- left：停止任何活动的左浮动
- right：停止任何活动的右浮动
- both：停止任何活动的左右浮动

## 定位
定位技术 (position) 允许我们将一个元素从它在页面的原始位置准确地移动到另外一个位置。

四个主要定位的类型:
- 静态定位 (Static positioning) 是每个元素默认的属性——它表示 “将元素放在文档布局流的默认位置——没有什么特殊的地方”。
- 相对定位 (Relative positioning) 允许我们相对元素在正常的文档流中的位置移动它——包括将两个元素叠放在页面上。这对于微调和精准设计 (design pinpointing) 非常有用。
- 绝对定位 (Absolute positioning) 将元素完全从页面的正常布局流中移出，类似将它单独放在一个图层中. 我们可以将元素相对于页面的 `<html>` 元素边缘固定，或者相对于离元素最近的被定位的祖先元素 (ancestor element)。绝对定位在创建复杂布局效果时非常有用，例如通过标签显示和隐藏的内容面板或者通过按钮控制滑动到屏幕中的信息面板.
- 固定定位 (Fixed positioning) 与绝对定位非常类似，除了它是将一个元素相对浏览器视口固定，而不是相对另外一个元素。 在创建类似页面滚动总是处于页面上方的导航菜单时非常有用。

文档流:
- 元素相互之间如何交互呢？ 正常的布局流是将元素放置在浏览器窗口视口内的系统。
## 练习定位案例
定位案例练习。
## 弹性盒子
稳定跨浏览器兼容性的能用来构建 CSS 布局的工具只有 floats 和 positioning。它们是既可行，表现也不错的布局方案，但是在某些布局方面它们就有限制，并且难以实现。

以下简单的布局要求是难以或不可能用这样的工具（ floats 和 positioning）方便且灵活的实现的：
- 在父内容里面垂直居中一个块内容。
- 使容器的所有子项占用等量的可用宽度 / 高度，而不管有多少宽度 / 高度可用。
- 使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同。

当元素为 flex 框时, 它们沿着两个轴来布局:
- 主轴（main axis）是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 main start 和 main end。
- 交叉轴（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为 cross start 和 cross end。

设置了 `display: flex` 的父元素, 被称为 flex 容器(flex container)。
在 flex 容器中表现为柔性盒子的元素被称之为 flex 项(flex item)。

- flex-direction 属性。指定主轴的方向（弹性盒子子类放置的地方）— 它默认值是 row。

弹性盒子的真正价值可以体现在它的灵活性 / 响应性。

flex: 缩写与全写，flex 可以指定最多三个不同值的缩写属性。
- 第一个就是上面所讨论过的无单位比例。可以单独指定全写 flex-grow 属性的值。
- 第二个无单位比例 `flex-shrink` 一般用于溢出容器的 flex 项。这指定了从每个 flex 项中取出多少溢出量，以阻止它们溢出它们的容器。 这是一个相当高级的弹性盒子功能，我们不会在本文中进一步说明。
- 第三个是上面讨论的最小值。可以单独指定全写 `flex-basis` 属性的值。

### 水平和锤子对齐
通过下面的两个属性:
1.`align-items` 控制 flex 项在交叉轴上的位置:
- 默认的值是 stretch，其会使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。
- center 值会使这些项保持其原有的高度，但是会在交叉轴居中。这就是那些按钮垂直居中的原因。
- 设置 `flex-start` 或 `flex-end` 这样使 flex 项在交叉轴的开始或结束处对齐所有的值。查看 align-items 了解更多。

2.`justify-content` 控制 flex 项在主轴上的位置:
- 默认值是 `flex-start`，这会使所有 flex 项都位于主轴的开始处。也可以用 flex-end 来让 flex 项到结尾处。
- center 在 `justify-content` 里也是可用的，可以让 flex 项在主轴居中。
- 而 `space-around` 是很有用的，它会使所有 flex 项沿着主轴均匀地分布，在任意一端都会留有一点空间。
- 还有一个值是 `space-between`，它和 `space-around` 非常相似，只是它不会在两端留下任何空间。

#### flex 项排序
弹性盒子也有可以改变 flex 项的布局位置的功能，而不会影响到源顺序（即 dom 树里元素的顺序）。这也是传统布局方式很难做到的一点。

- 所有 flex 项默认的 order 值是 0。
- order 值大的 flex 项比 order 值小的在显示顺序中更靠后。
- 相同 order 值的 flex 项按源顺序显示。所以假如你有四个元素，其 order 值分别是 2，1，1 和 0，那么它们的显示顺序就分别是第四，第二，第三，和第一。
- 第三个元素显示在第二个后面是因为它们的 order 值一样，且第三个元素在源顺序中排在第二个后面。

## 网格布局
什么是网格布局？
网格仅仅是由水平和垂直线集合创建的一个模式，我们可以根据这个模式排列我们的设计元素。它们帮助我们创建设计——在页面之间移动时元素不会跳动或更改宽度，从而在我们的网站上提供高一致性。

网格通常具有列（column），行（row），以及在每行和列之间的间隙——通常称为沟槽（gutter）。

### 创建流体网络
想要一个灵活（流体）网格，它将随着浏览器视口中的可用空间而增长和缩小。为了实现这一点参考像素并将其转化为百分比。

将固定的宽度变为基于百分比的灵活（flexible）宽度的公式如下。
```
target / context = result
```

- calc 函数计算
- 语义与非语义网格系统
- 在网格中使用偏移容器
- 浮动网格限制

### Flexbox 网格

以前面的 demo 为例, 设置 row-> display 为 flex 指定元素呈现为 flex 类型。  

### 第三方网格
例如流行的 [BootStrap](http://getbootstrap.com/) & [Fundation](https://foundation.zurb.com/) 网格系统。

### 本地网格与网格布局
